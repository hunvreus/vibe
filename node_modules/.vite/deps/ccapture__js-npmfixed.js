import {
  __commonJS
} from "./chunk-UP2VWCW5.js";

// node_modules/ccapture.js-npmfixed/src/tar.js
var require_tar = __commonJS({
  "node_modules/ccapture.js-npmfixed/src/tar.js"(exports, module) {
    (function() {
      "use strict";
      var lookup = [
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "x",
        "y",
        "z",
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "+",
        "/"
      ];
      function clean(length) {
        var i, buffer = new Uint8Array(length);
        for (i = 0; i < length; i += 1) {
          buffer[i] = 0;
        }
        return buffer;
      }
      function extend(orig, length, addLength, multipleOf) {
        var newSize = length + addLength, buffer = clean((parseInt(newSize / multipleOf) + 1) * multipleOf);
        buffer.set(orig);
        return buffer;
      }
      function pad(num, bytes, base) {
        num = num.toString(base || 8);
        return "000000000000".substr(num.length + 12 - bytes) + num;
      }
      function stringToUint8(input, out, offset) {
        var i, length;
        out = out || clean(input.length);
        offset = offset || 0;
        for (i = 0, length = input.length; i < length; i += 1) {
          out[offset] = input.charCodeAt(i);
          offset += 1;
        }
        return out;
      }
      function uint8ToBase64(uint8) {
        var i, extraBytes = uint8.length % 3, output = "", temp, length;
        function tripletToBase64(num) {
          return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
        }
        ;
        for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
          temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
          output += tripletToBase64(temp);
        }
        switch (output.length % 4) {
          case 1:
            output += "=";
            break;
          case 2:
            output += "==";
            break;
          default:
            break;
        }
        return output;
      }
      window.utils = {};
      window.utils.clean = clean;
      window.utils.pad = pad;
      window.utils.extend = extend;
      window.utils.stringToUint8 = stringToUint8;
      window.utils.uint8ToBase64 = uint8ToBase64;
    })();
    (function() {
      "use strict";
      var utils = window.utils, headerFormat;
      headerFormat = [
        {
          "field": "fileName",
          "length": 100
        },
        {
          "field": "fileMode",
          "length": 8
        },
        {
          "field": "uid",
          "length": 8
        },
        {
          "field": "gid",
          "length": 8
        },
        {
          "field": "fileSize",
          "length": 12
        },
        {
          "field": "mtime",
          "length": 12
        },
        {
          "field": "checksum",
          "length": 8
        },
        {
          "field": "type",
          "length": 1
        },
        {
          "field": "linkName",
          "length": 100
        },
        {
          "field": "ustar",
          "length": 8
        },
        {
          "field": "owner",
          "length": 32
        },
        {
          "field": "group",
          "length": 32
        },
        {
          "field": "majorNumber",
          "length": 8
        },
        {
          "field": "minorNumber",
          "length": 8
        },
        {
          "field": "filenamePrefix",
          "length": 155
        },
        {
          "field": "padding",
          "length": 12
        }
      ];
      function formatHeader(data, cb) {
        var buffer = utils.clean(512), offset = 0;
        headerFormat.forEach(function(value) {
          var str = data[value.field] || "", i, length;
          for (i = 0, length = str.length; i < length; i += 1) {
            buffer[offset] = str.charCodeAt(i);
            offset += 1;
          }
          offset += value.length - i;
        });
        if (typeof cb === "function") {
          return cb(buffer, offset);
        }
        return buffer;
      }
      window.header = {};
      window.header.structure = headerFormat;
      window.header.format = formatHeader;
    })();
    (function() {
      "use strict";
      var header = window.header, utils = window.utils, recordSize = 512, blockSize;
      function Tar(recordsPerBlock) {
        this.written = 0;
        blockSize = (recordsPerBlock || 20) * recordSize;
        this.out = utils.clean(blockSize);
        this.blocks = [];
        this.length = 0;
      }
      Tar.prototype.append = function(filepath, input, opts, callback) {
        var data, checksum, mode, mtime, uid, gid, headerArr;
        if (typeof input === "string") {
          input = utils.stringToUint8(input);
        } else if (input.constructor !== Uint8Array.prototype.constructor) {
          throw "Invalid input type. You gave me: " + input.constructor.toString().match(/function\s*([$A-Za-z_][0-9A-Za-z_]*)\s*\(/)[1];
        }
        if (typeof opts === "function") {
          callback = opts;
          opts = {};
        }
        opts = opts || {};
        mode = opts.mode || parseInt("777", 8) & 4095;
        mtime = opts.mtime || Math.floor(+/* @__PURE__ */ new Date() / 1e3);
        uid = opts.uid || 0;
        gid = opts.gid || 0;
        data = {
          fileName: filepath,
          fileMode: utils.pad(mode, 7),
          uid: utils.pad(uid, 7),
          gid: utils.pad(gid, 7),
          fileSize: utils.pad(input.length, 11),
          mtime: utils.pad(mtime, 11),
          checksum: "        ",
          type: "0",
          // just a file
          ustar: "ustar  ",
          owner: opts.owner || "",
          group: opts.group || ""
        };
        checksum = 0;
        Object.keys(data).forEach(function(key) {
          var i, value = data[key], length;
          for (i = 0, length = value.length; i < length; i += 1) {
            checksum += value.charCodeAt(i);
          }
        });
        data.checksum = utils.pad(checksum, 6) + "\0 ";
        headerArr = header.format(data);
        var headerLength = Math.ceil(headerArr.length / recordSize) * recordSize;
        var inputLength = Math.ceil(input.length / recordSize) * recordSize;
        this.blocks.push({ header: headerArr, input, headerLength, inputLength });
      };
      Tar.prototype.save = function() {
        var buffers = [];
        var chunks = [];
        var length = 0;
        var max = Math.pow(2, 20);
        var chunk = [];
        this.blocks.forEach(function(b) {
          if (length + b.headerLength + b.inputLength > max) {
            chunks.push({ blocks: chunk, length });
            chunk = [];
            length = 0;
          }
          chunk.push(b);
          length += b.headerLength + b.inputLength;
        });
        chunks.push({ blocks: chunk, length });
        chunks.forEach(function(c) {
          var buffer = new Uint8Array(c.length);
          var written = 0;
          c.blocks.forEach(function(b) {
            buffer.set(b.header, written);
            written += b.headerLength;
            buffer.set(b.input, written);
            written += b.inputLength;
          });
          buffers.push(buffer);
        });
        buffers.push(new Uint8Array(2 * recordSize));
        return new Blob(buffers, { type: "octet/stream" });
      };
      Tar.prototype.clear = function() {
        this.written = 0;
        this.out = utils.clean(blockSize);
      };
      if (typeof module !== "undefined" && typeof module.exports !== "undefined") {
        module.exports = Tar;
      } else {
        window.Tar = Tar;
      }
    })();
  }
});

// node_modules/ccapture.js-npmfixed/src/download.js
var require_download = __commonJS({
  "node_modules/ccapture.js-npmfixed/src/download.js"(exports, module) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof exports === "object") {
        module.exports = factory();
      } else {
        root.download = factory();
      }
    })(exports, function() {
      return function download(data, strFileName, strMimeType) {
        var self2 = window, defaultMime = "application/octet-stream", mimeType = strMimeType || defaultMime, payload = data, url = !strFileName && !strMimeType && payload, anchor = document.createElement("a"), toString = function(a) {
          return String(a);
        }, myBlob = self2.Blob || self2.MozBlob || self2.WebKitBlob || toString, fileName = strFileName || "download", blob, reader;
        myBlob = myBlob.call ? myBlob.bind(self2) : Blob;
        if (String(this) === "true") {
          payload = [payload, mimeType];
          mimeType = payload[0];
          payload = payload[1];
        }
        if (url && url.length < 2048) {
          fileName = url.split("/").pop().split("?")[0];
          anchor.href = url;
          if (anchor.href.indexOf(url) !== -1) {
            var ajax = new XMLHttpRequest();
            ajax.open("GET", url, true);
            ajax.responseType = "blob";
            ajax.onload = function(e) {
              download(e.target.response, fileName, defaultMime);
            };
            setTimeout(function() {
              ajax.send();
            }, 0);
            return ajax;
          }
        }
        if (/^data:([\w+-]+\/[\w+.-]+)?[,;]/.test(payload)) {
          if (payload.length > 1024 * 1024 * 1.999 && myBlob !== toString) {
            payload = dataUrlToBlob(payload);
            mimeType = payload.type || defaultMime;
          } else {
            return navigator.msSaveBlob ? (
              // IE10 can't do a[download], only Blobs:
              navigator.msSaveBlob(dataUrlToBlob(payload), fileName)
            ) : saver(payload);
          }
        } else {
          if (/([\x80-\xff])/.test(payload)) {
            var i = 0, tempUiArr = new Uint8Array(payload.length), mx = tempUiArr.length;
            for (i; i < mx; ++i) tempUiArr[i] = payload.charCodeAt(i);
            payload = new myBlob([tempUiArr], { type: mimeType });
          }
        }
        blob = payload instanceof myBlob ? payload : new myBlob([payload], { type: mimeType });
        function dataUrlToBlob(strUrl) {
          var parts = strUrl.split(/[:;,]/), type = parts[1], indexDecoder = strUrl.indexOf("charset") > 0 ? 3 : 2, decoder = parts[indexDecoder] == "base64" ? atob : decodeURIComponent, binData = decoder(parts.pop()), mx2 = binData.length, i2 = 0, uiArr = new Uint8Array(mx2);
          for (i2; i2 < mx2; ++i2) uiArr[i2] = binData.charCodeAt(i2);
          return new myBlob([uiArr], { type });
        }
        function saver(url2, winMode) {
          if ("download" in anchor) {
            anchor.href = url2;
            anchor.setAttribute("download", fileName);
            anchor.className = "download-js-link";
            anchor.innerHTML = "downloading...";
            anchor.style.display = "none";
            anchor.addEventListener("click", function(e) {
              e.stopPropagation();
              this.removeEventListener("click", arguments.callee);
            });
            document.body.appendChild(anchor);
            setTimeout(function() {
              anchor.click();
              document.body.removeChild(anchor);
              if (winMode === true) {
                setTimeout(function() {
                  self2.URL.revokeObjectURL(anchor.href);
                }, 250);
              }
            }, 66);
            return true;
          }
          if (/(Version)\/(\d+)\.(\d+)(?:\.(\d+))?.*Safari\//.test(navigator.userAgent)) {
            if (/^data:/.test(url2)) url2 = "data:" + url2.replace(/^data:([\w\/\-\+]+)/, defaultMime);
            if (!window.open(url2)) {
              if (confirm("Displaying New Document\n\nUse Save As... to download, then click back to return to this page.")) {
                location.href = url2;
              }
            }
            return true;
          }
          var f = document.createElement("iframe");
          document.body.appendChild(f);
          if (!winMode && /^data:/.test(url2)) {
            url2 = "data:" + url2.replace(/^data:([\w\/\-\+]+)/, defaultMime);
          }
          f.src = url2;
          setTimeout(function() {
            document.body.removeChild(f);
          }, 333);
        }
        if (navigator.msSaveBlob) {
          return navigator.msSaveBlob(blob, fileName);
        }
        if (self2.URL) {
          saver(self2.URL.createObjectURL(blob), true);
        } else {
          if (typeof blob === "string" || blob.constructor === toString) {
            try {
              return saver("data:" + mimeType + ";base64," + self2.btoa(blob));
            } catch (y) {
              return saver("data:" + mimeType + "," + encodeURIComponent(blob));
            }
          }
          reader = new FileReader();
          reader.onload = function(e) {
            saver(this.result);
          };
          reader.readAsDataURL(blob);
        }
        return true;
      };
    });
  }
});

// node_modules/ccapture.js-npmfixed/src/gif.js
var require_gif = __commonJS({
  "node_modules/ccapture.js-npmfixed/src/gif.js"(exports) {
    (function(c) {
      function a(b2, d) {
        if ({}.hasOwnProperty.call(a.cache, b2)) return a.cache[b2];
        var e = a.resolve(b2);
        if (!e) throw new Error("Failed to resolve module " + b2);
        var c2 = { id: b2, require: a, filename: b2, exports: {}, loaded: false, parent: d, children: [] };
        d && d.children.push(c2);
        var f = b2.slice(0, b2.lastIndexOf("/") + 1);
        return a.cache[b2] = c2.exports, e.call(c2.exports, c2, c2.exports, f, b2), c2.loaded = true, a.cache[b2] = c2.exports;
      }
      a.modules = {}, a.cache = {}, a.resolve = function(b2) {
        return {}.hasOwnProperty.call(a.modules, b2) ? a.modules[b2] : void 0;
      }, a.define = function(b2, c2) {
        a.modules[b2] = c2;
      };
      var b = function(a2) {
        return a2 = "/", { title: "browser", version: "v0.10.26", browser: true, env: {}, argv: [], nextTick: c.setImmediate || function(a3) {
          setTimeout(a3, 0);
        }, cwd: function() {
          return a2;
        }, chdir: function(b2) {
          a2 = b2;
        } };
      }();
      a.define("/gif.coffee", function(d, m, l, k) {
        function g(a2, b3) {
          return {}.hasOwnProperty.call(a2, b3);
        }
        function j(d2, b3) {
          for (var a2 = 0, c3 = b3.length; a2 < c3; ++a2) if (a2 in b3 && b3[a2] === d2) return true;
          return false;
        }
        function i(a2, b3) {
          function d2() {
            this.constructor = a2;
          }
          for (var c3 in b3) g(b3, c3) && (a2[c3] = b3[c3]);
          return d2.prototype = b3.prototype, a2.prototype = new d2(), a2.__super__ = b3.prototype, a2;
        }
        var h, c2, f, b2, e;
        f = a("events", d).EventEmitter, h = a("/browser.coffee", d), e = function(d2) {
          function a2(d3) {
            var a3, b3;
            this.running = false, this.options = {}, this.frames = [], this.freeWorkers = [], this.activeWorkers = [], this.setOptions(d3);
            for (a3 in c2) b3 = c2[a3], null != this.options[a3] ? this.options[a3] : this.options[a3] = b3;
          }
          return i(a2, d2), c2 = { workerScript: "gif.worker.js", workers: 2, repeat: 0, background: "#fff", quality: 10, width: null, height: null, transparent: null }, b2 = { delay: 500, copy: false }, a2.prototype.setOption = function(a3, b3) {
            return this.options[a3] = b3, null != this._canvas && (a3 === "width" || a3 === "height") ? this._canvas[a3] = b3 : void 0;
          }, a2.prototype.setOptions = function(b3) {
            var a3, c3;
            return (function(d3) {
              for (a3 in b3) {
                if (!g(b3, a3)) continue;
                c3 = b3[a3], d3.push(this.setOption(a3, c3));
              }
              return d3;
            }).call(this, []);
          }, a2.prototype.addFrame = function(a3, d3) {
            var c3, e2;
            null == d3 && (d3 = {}), c3 = {}, c3.transparent = this.options.transparent;
            for (e2 in b2) c3[e2] = d3[e2] || b2[e2];
            if (null != this.options.width || this.setOption("width", a3.width), null != this.options.height || this.setOption("height", a3.height), "undefined" !== typeof ImageData && null != ImageData && a3 instanceof ImageData) c3.data = a3.data;
            else if ("undefined" !== typeof CanvasRenderingContext2D && null != CanvasRenderingContext2D && a3 instanceof CanvasRenderingContext2D || "undefined" !== typeof WebGLRenderingContext && null != WebGLRenderingContext && a3 instanceof WebGLRenderingContext) d3.copy ? c3.data = this.getContextData(a3) : c3.context = a3;
            else if (null != a3.childNodes) d3.copy ? c3.data = this.getImageData(a3) : c3.image = a3;
            else throw new Error("Invalid image");
            return this.frames.push(c3);
          }, a2.prototype.render = function() {
            var d3, a3;
            if (this.running) throw new Error("Already running");
            if (!(null != this.options.width && null != this.options.height)) throw new Error("Width and height must be set prior to rendering");
            this.running = true, this.nextFrame = 0, this.finishedFrames = 0, this.imageParts = (function(c4) {
              for (var b4 = (function() {
                var b5;
                b5 = [];
                for (var a5 = 0; 0 <= this.frames.length ? a5 < this.frames.length : a5 > this.frames.length; 0 <= this.frames.length ? ++a5 : --a5) b5.push(a5);
                return b5;
              }).apply(this, arguments), a4 = 0, e3 = b4.length; a4 < e3; ++a4) d3 = b4[a4], c4.push(null);
              return c4;
            }).call(this, []), a3 = this.spawnWorkers();
            for (var c3 = (function() {
              var c4;
              c4 = [];
              for (var b4 = 0; 0 <= a3 ? b4 < a3 : b4 > a3; 0 <= a3 ? ++b4 : --b4) c4.push(b4);
              return c4;
            }).apply(this, arguments), b3 = 0, e2 = c3.length; b3 < e2; ++b3) d3 = c3[b3], this.renderNextFrame();
            return this.emit("start"), this.emit("progress", 0);
          }, a2.prototype.abort = function() {
            var a3;
            while (true) {
              if (a3 = this.activeWorkers.shift(), !(null != a3)) break;
              console.log("killing active worker"), a3.terminate();
            }
            return this.running = false, this.emit("abort");
          }, a2.prototype.spawnWorkers = function() {
            var a3;
            return a3 = Math.min(this.options.workers, this.frames.length), (function() {
              var c3;
              c3 = [];
              for (var b3 = this.freeWorkers.length; this.freeWorkers.length <= a3 ? b3 < a3 : b3 > a3; this.freeWorkers.length <= a3 ? ++b3 : --b3) c3.push(b3);
              return c3;
            }).apply(this, arguments).forEach(/* @__PURE__ */ function(a4) {
              return function(c3) {
                var b3;
                return console.log("spawning worker " + c3), b3 = new Worker(a4.options.workerScript), b3.onmessage = /* @__PURE__ */ function(a5) {
                  return function(c4) {
                    return a5.activeWorkers.splice(a5.activeWorkers.indexOf(b3), 1), a5.freeWorkers.push(b3), a5.frameFinished(c4.data);
                  };
                }(a4), a4.freeWorkers.push(b3);
              };
            }(this)), a3;
          }, a2.prototype.frameFinished = function(a3) {
            return console.log("frame " + a3.index + " finished - " + this.activeWorkers.length + " active"), this.finishedFrames++, this.emit("progress", this.finishedFrames / this.frames.length), this.imageParts[a3.index] = a3, j(null, this.imageParts) ? this.renderNextFrame() : this.finishRendering();
          }, a2.prototype.finishRendering = function() {
            var e2, a3, k2, m2, b3, d3, h2;
            b3 = 0;
            for (var f2 = 0, j2 = this.imageParts.length; f2 < j2; ++f2) a3 = this.imageParts[f2], b3 += (a3.data.length - 1) * a3.pageSize + a3.cursor;
            b3 += a3.pageSize - a3.cursor, console.log("rendering finished - filesize " + Math.round(b3 / 1e3) + "kb"), e2 = new Uint8Array(b3), d3 = 0;
            for (var g2 = 0, l2 = this.imageParts.length; g2 < l2; ++g2) {
              a3 = this.imageParts[g2];
              for (var c3 = 0, i2 = a3.data.length; c3 < i2; ++c3) h2 = a3.data[c3], k2 = c3, e2.set(h2, d3), k2 === a3.data.length - 1 ? d3 += a3.cursor : d3 += a3.pageSize;
            }
            return m2 = new Blob([e2], { type: "image/gif" }), this.emit("finished", m2, e2);
          }, a2.prototype.renderNextFrame = function() {
            var c3, a3, b3;
            if (this.freeWorkers.length === 0) throw new Error("No free workers");
            return this.nextFrame >= this.frames.length ? void 0 : (c3 = this.frames[this.nextFrame++], b3 = this.freeWorkers.shift(), a3 = this.getTask(c3), console.log("starting frame " + (a3.index + 1) + " of " + this.frames.length), this.activeWorkers.push(b3), b3.postMessage(a3));
          }, a2.prototype.getContextData = function(a3) {
            return a3.getImageData(0, 0, this.options.width, this.options.height).data;
          }, a2.prototype.getImageData = function(b3) {
            var a3;
            return null != this._canvas || (this._canvas = document.createElement("canvas"), this._canvas.width = this.options.width, this._canvas.height = this.options.height), a3 = this._canvas.getContext("2d"), a3.setFill = this.options.background, a3.fillRect(0, 0, this.options.width, this.options.height), a3.drawImage(b3, 0, 0), this.getContextData(a3);
          }, a2.prototype.getTask = function(a3) {
            var c3, b3;
            if (c3 = this.frames.indexOf(a3), b3 = { index: c3, last: c3 === this.frames.length - 1, delay: a3.delay, transparent: a3.transparent, width: this.options.width, height: this.options.height, quality: this.options.quality, repeat: this.options.repeat, canTransfer: h.name === "chrome" }, null != a3.data) b3.data = a3.data;
            else if (null != a3.context) b3.data = this.getContextData(a3.context);
            else if (null != a3.image) b3.data = this.getImageData(a3.image);
            else throw new Error("Invalid frame");
            return b3;
          }, a2;
        }(f), d.exports = e;
      }), a.define("/browser.coffee", function(f, g, h, i) {
        var a2, d, e, c2, b2;
        c2 = navigator.userAgent.toLowerCase(), e = navigator.platform.toLowerCase(), b2 = c2.match(/(opera|ie|firefox|chrome|version)[\s\/:]([\w\d\.]+)?.*?(safari|version[\s\/:]([\w\d\.]+)|$)/) || [null, "unknown", 0], d = b2[1] === "ie" && document.documentMode, a2 = { name: b2[1] === "version" ? b2[3] : b2[1], version: d || parseFloat(b2[1] === "opera" && b2[4] ? b2[4] : b2[2]), platform: { name: c2.match(/ip(?:ad|od|hone)/) ? "ios" : (c2.match(/(?:webos|android)/) || e.match(/mac|win|linux/) || ["other"])[0] } }, a2[a2.name] = true, a2[a2.name + parseInt(a2.version, 10)] = true, a2.platform[a2.platform.name] = true, f.exports = a2;
      }), a.define("events", function(f, e, g, h) {
        b.EventEmitter || (b.EventEmitter = function() {
        });
        var a2 = e.EventEmitter = b.EventEmitter, c2 = typeof Array.isArray === "function" ? Array.isArray : function(a3) {
          return Object.prototype.toString.call(a3) === "[object Array]";
        }, d = 10;
        a2.prototype.setMaxListeners = function(a3) {
          this._events || (this._events = {}), this._events.maxListeners = a3;
        }, a2.prototype.emit = function(f2) {
          if (f2 === "error" && (!(this._events && this._events.error) || c2(this._events.error) && !this._events.error.length)) throw arguments[1] instanceof Error ? arguments[1] : new Error("Uncaught, unspecified 'error' event.");
          if (!this._events) return false;
          var a3 = this._events[f2];
          if (!a3) return false;
          if (!(typeof a3 == "function")) if (c2(a3)) {
            var b2 = Array.prototype.slice.call(arguments, 1), e2 = a3.slice();
            for (var d2 = 0, g2 = e2.length; d2 < g2; d2++) e2[d2].apply(this, b2);
            return true;
          } else return false;
          switch (arguments.length) {
            case 1:
              a3.call(this);
              break;
            case 2:
              a3.call(this, arguments[1]);
              break;
            case 3:
              a3.call(this, arguments[1], arguments[2]);
              break;
            default:
              var b2 = Array.prototype.slice.call(arguments, 1);
              a3.apply(this, b2);
          }
          return true;
        }, a2.prototype.addListener = function(a3, b2) {
          if ("function" !== typeof b2) throw new Error("addListener only takes instances of Function");
          if (this._events || (this._events = {}), this.emit("newListener", a3, b2), !this._events[a3]) this._events[a3] = b2;
          else if (c2(this._events[a3])) {
            if (!this._events[a3].warned) {
              var e2;
              this._events.maxListeners !== void 0 ? e2 = this._events.maxListeners : e2 = d, e2 && e2 > 0 && this._events[a3].length > e2 && (this._events[a3].warned = true, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[a3].length), console.trace());
            }
            this._events[a3].push(b2);
          } else this._events[a3] = [this._events[a3], b2];
          return this;
        }, a2.prototype.on = a2.prototype.addListener, a2.prototype.once = function(b2, c3) {
          var a3 = this;
          return a3.on(b2, function d2() {
            a3.removeListener(b2, d2), c3.apply(this, arguments);
          }), this;
        }, a2.prototype.removeListener = function(a3, d2) {
          if ("function" !== typeof d2) throw new Error("removeListener only takes instances of Function");
          if (!(this._events && this._events[a3])) return this;
          var b2 = this._events[a3];
          if (c2(b2)) {
            var e2 = b2.indexOf(d2);
            if (e2 < 0) return this;
            b2.splice(e2, 1), b2.length == 0 && delete this._events[a3];
          } else this._events[a3] === d2 && delete this._events[a3];
          return this;
        }, a2.prototype.removeAllListeners = function(a3) {
          return a3 && this._events && this._events[a3] && (this._events[a3] = null), this;
        }, a2.prototype.listeners = function(a3) {
          return this._events || (this._events = {}), this._events[a3] || (this._events[a3] = []), c2(this._events[a3]) || (this._events[a3] = [this._events[a3]]), this._events[a3];
        };
      }), c.GIF = a("/gif.coffee");
    }).call(exports, exports);
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/ccapture.js-npmfixed/src/webm-writer-0.2.0.js
var require_webm_writer_0_2_0 = __commonJS({
  "node_modules/ccapture.js-npmfixed/src/webm-writer-0.2.0.js"(exports, module) {
    "use strict";
    (function() {
      var isNodeEnviroment = typeof module !== "undefined" && typeof module.exports !== "undefined";
      var ArrayBufferDataStream = function(length) {
        this.data = new Uint8Array(length);
        this.pos = 0;
      };
      ArrayBufferDataStream.prototype.seek = function(offset) {
        this.pos = offset;
      };
      ArrayBufferDataStream.prototype.writeBytes = function(arr) {
        for (var i = 0; i < arr.length; i++) {
          this.data[this.pos++] = arr[i];
        }
      };
      ArrayBufferDataStream.prototype.writeByte = function(b) {
        this.data[this.pos++] = b;
      };
      ArrayBufferDataStream.prototype.writeU8 = ArrayBufferDataStream.prototype.writeByte;
      ArrayBufferDataStream.prototype.writeU16BE = function(u) {
        this.data[this.pos++] = u >> 8;
        this.data[this.pos++] = u;
      };
      ArrayBufferDataStream.prototype.writeDoubleBE = function(d) {
        var bytes = new Uint8Array(new Float64Array([d]).buffer);
        for (var i = bytes.length - 1; i >= 0; i--) {
          this.writeByte(bytes[i]);
        }
      };
      ArrayBufferDataStream.prototype.writeFloatBE = function(d) {
        var bytes = new Uint8Array(new Float32Array([d]).buffer);
        for (var i = bytes.length - 1; i >= 0; i--) {
          this.writeByte(bytes[i]);
        }
      };
      ArrayBufferDataStream.prototype.writeString = function(s) {
        for (var i = 0; i < s.length; i++) {
          this.data[this.pos++] = s.charCodeAt(i);
        }
      };
      ArrayBufferDataStream.prototype.writeEBMLVarIntWidth = function(i, width) {
        switch (width) {
          case 1:
            this.writeU8(1 << 7 | i);
            break;
          case 2:
            this.writeU8(1 << 6 | i >> 8);
            this.writeU8(i);
            break;
          case 3:
            this.writeU8(1 << 5 | i >> 16);
            this.writeU8(i >> 8);
            this.writeU8(i);
            break;
          case 4:
            this.writeU8(1 << 4 | i >> 24);
            this.writeU8(i >> 16);
            this.writeU8(i >> 8);
            this.writeU8(i);
            break;
          case 5:
            this.writeU8(1 << 3 | i / 4294967296 & 7);
            this.writeU8(i >> 24);
            this.writeU8(i >> 16);
            this.writeU8(i >> 8);
            this.writeU8(i);
            break;
          default:
            throw new RuntimeException("Bad EBML VINT size " + width);
        }
      };
      ArrayBufferDataStream.prototype.measureEBMLVarInt = function(val) {
        if (val < (1 << 7) - 1) {
          return 1;
        } else if (val < (1 << 14) - 1) {
          return 2;
        } else if (val < (1 << 21) - 1) {
          return 3;
        } else if (val < (1 << 28) - 1) {
          return 4;
        } else if (val < 34359738367) {
          return 5;
        } else {
          throw new RuntimeException("EBML VINT size not supported " + val);
        }
      };
      ArrayBufferDataStream.prototype.writeEBMLVarInt = function(i) {
        this.writeEBMLVarIntWidth(i, this.measureEBMLVarInt(i));
      };
      ArrayBufferDataStream.prototype.writeUnsignedIntBE = function(u, width) {
        if (width === void 0) {
          width = this.measureUnsignedInt(u);
        }
        switch (width) {
          case 5:
            this.writeU8(Math.floor(u / 4294967296));
          // Need to use division to access >32 bits of floating point var
          case 4:
            this.writeU8(u >> 24);
          case 3:
            this.writeU8(u >> 16);
          case 2:
            this.writeU8(u >> 8);
          case 1:
            this.writeU8(u);
            break;
          default:
            throw new RuntimeException("Bad UINT size " + width);
        }
      };
      ArrayBufferDataStream.prototype.measureUnsignedInt = function(val) {
        if (val < 1 << 8) {
          return 1;
        } else if (val < 1 << 16) {
          return 2;
        } else if (val < 1 << 24) {
          return 3;
        } else if (val < 4294967296) {
          return 4;
        } else {
          return 5;
        }
      };
      ArrayBufferDataStream.prototype.getAsDataArray = function() {
        if (this.pos < this.data.byteLength) {
          return this.data.subarray(0, this.pos);
        } else if (this.pos == this.data.byteLength) {
          return this.data;
        } else {
          throw "ArrayBufferDataStream's pos lies beyond end of buffer";
        }
      };
      window.ArrayBufferDataStream = ArrayBufferDataStream;
      var BlobBuffer = /* @__PURE__ */ function(fs) {
        return function(destination) {
          var buffer = [], writePromise = Promise.resolve(), fileWriter = null, fd = null;
          if (typeof FileWriter !== "undefined" && destination instanceof FileWriter) {
            fileWriter = destination;
          } else if (fs && destination) {
            fd = destination;
          }
          this.pos = 0;
          this.length = 0;
          function readBlobAsBuffer(blob) {
            return new Promise(function(resolve, reject) {
              var reader = new FileReader();
              reader.addEventListener("loadend", function() {
                resolve(reader.result);
              });
              reader.readAsArrayBuffer(blob);
            });
          }
          function convertToUint8Array(thing) {
            return new Promise(function(resolve, reject) {
              if (thing instanceof Uint8Array) {
                resolve(thing);
              } else if (thing instanceof ArrayBuffer || ArrayBuffer.isView(thing)) {
                resolve(new Uint8Array(thing));
              } else if (thing instanceof Blob) {
                resolve(readBlobAsBuffer(thing).then(function(buffer2) {
                  return new Uint8Array(buffer2);
                }));
              } else {
                resolve(readBlobAsBuffer(new Blob([thing])).then(function(buffer2) {
                  return new Uint8Array(buffer2);
                }));
              }
            });
          }
          function measureData(data) {
            var result = data.byteLength || data.length || data.size;
            if (!Number.isInteger(result)) {
              throw "Failed to determine size of element";
            }
            return result;
          }
          this.seek = function(offset) {
            if (offset < 0) {
              throw "Offset may not be negative";
            }
            if (isNaN(offset)) {
              throw "Offset may not be NaN";
            }
            if (offset > this.length) {
              throw "Seeking beyond the end of file is not allowed";
            }
            this.pos = offset;
          };
          this.write = function(data) {
            var newEntry = {
              offset: this.pos,
              data,
              length: measureData(data)
            }, isAppend = newEntry.offset >= this.length;
            this.pos += newEntry.length;
            this.length = Math.max(this.length, this.pos);
            writePromise = writePromise.then(function() {
              if (fd) {
                return new Promise(function(resolve, reject) {
                  convertToUint8Array(newEntry.data).then(function(dataArray) {
                    var totalWritten = 0, buffer2 = Buffer.from(dataArray.buffer), handleWriteComplete = function(err, written, buffer3) {
                      totalWritten += written;
                      if (totalWritten >= buffer3.length) {
                        resolve();
                      } else {
                        fs.write(fd, buffer3, totalWritten, buffer3.length - totalWritten, newEntry.offset + totalWritten, handleWriteComplete);
                      }
                    };
                    fs.write(fd, buffer2, 0, buffer2.length, newEntry.offset, handleWriteComplete);
                  });
                });
              } else if (fileWriter) {
                return new Promise(function(resolve, reject) {
                  fileWriter.onwriteend = resolve;
                  fileWriter.seek(newEntry.offset);
                  fileWriter.write(new Blob([newEntry.data]));
                });
              } else if (!isAppend) {
                for (var i = 0; i < buffer.length; i++) {
                  var entry = buffer[i];
                  if (!(newEntry.offset + newEntry.length <= entry.offset || newEntry.offset >= entry.offset + entry.length)) {
                    if (newEntry.offset < entry.offset || newEntry.offset + newEntry.length > entry.offset + entry.length) {
                      throw new Error("Overwrite crosses blob boundaries");
                    }
                    if (newEntry.offset == entry.offset && newEntry.length == entry.length) {
                      entry.data = newEntry.data;
                      return;
                    } else {
                      return convertToUint8Array(entry.data).then(function(entryArray) {
                        entry.data = entryArray;
                        return convertToUint8Array(newEntry.data);
                      }).then(function(newEntryArray) {
                        newEntry.data = newEntryArray;
                        entry.data.set(newEntry.data, newEntry.offset - entry.offset);
                      });
                    }
                  }
                }
              }
              buffer.push(newEntry);
            });
          };
          this.complete = function(mimeType) {
            if (fd || fileWriter) {
              writePromise = writePromise.then(function() {
                return null;
              });
            } else {
              writePromise = writePromise.then(function() {
                var result = [];
                for (var i = 0; i < buffer.length; i++) {
                  result.push(buffer[i].data);
                }
                return new Blob(result, { mimeType });
              });
            }
            return writePromise;
          };
        };
      }(isNodeEnviroment ? require_fs() : null);
      window.BlobBuffer = BlobBuffer;
      var WebMWriter = function(ArrayBufferDataStream2, BlobBuffer2) {
        function extend(base, top) {
          var target = {};
          [base, top].forEach(function(obj) {
            for (var prop in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                target[prop] = obj[prop];
              }
            }
          });
          return target;
        }
        function decodeBase64WebPDataURL(url) {
          if (typeof url !== "string" || !url.match(/^data:image\/webp;base64,/i)) {
            return false;
          }
          return window.atob(url.substring("data:image/webp;base64,".length));
        }
        function stringToArrayBuffer(string) {
          var buffer = new ArrayBuffer(string.length), int8Array = new Uint8Array(buffer);
          for (var i = 0; i < string.length; i++) {
            int8Array[i] = string.charCodeAt(i);
          }
          return buffer;
        }
        function renderAsWebP(canvas, quality) {
          var frame = canvas.toDataURL("image/webp", { quality });
          return decodeBase64WebPDataURL(frame);
        }
        function extractKeyframeFromWebP(webP) {
          var keyframeStartIndex = webP.indexOf("VP8 ");
          if (keyframeStartIndex == -1) {
            throw "Failed to identify beginning of keyframe in WebP image";
          }
          keyframeStartIndex += "VP8 ".length + 4;
          return webP.substring(keyframeStartIndex);
        }
        function EBMLFloat32(value) {
          this.value = value;
        }
        function EBMLFloat64(value) {
          this.value = value;
        }
        function writeEBML(buffer, bufferFileOffset, ebml) {
          if (Array.isArray(ebml)) {
            for (var i = 0; i < ebml.length; i++) {
              writeEBML(buffer, bufferFileOffset, ebml[i]);
            }
          } else if (typeof ebml === "string") {
            buffer.writeString(ebml);
          } else if (ebml instanceof Uint8Array) {
            buffer.writeBytes(ebml);
          } else if (ebml.id) {
            ebml.offset = buffer.pos + bufferFileOffset;
            buffer.writeUnsignedIntBE(ebml.id);
            if (Array.isArray(ebml.data)) {
              var sizePos, dataBegin, dataEnd;
              if (ebml.size === -1) {
                buffer.writeByte(255);
              } else {
                sizePos = buffer.pos;
                buffer.writeBytes([0, 0, 0, 0]);
              }
              dataBegin = buffer.pos;
              ebml.dataOffset = dataBegin + bufferFileOffset;
              writeEBML(buffer, bufferFileOffset, ebml.data);
              if (ebml.size !== -1) {
                dataEnd = buffer.pos;
                ebml.size = dataEnd - dataBegin;
                buffer.seek(sizePos);
                buffer.writeEBMLVarIntWidth(ebml.size, 4);
                buffer.seek(dataEnd);
              }
            } else if (typeof ebml.data === "string") {
              buffer.writeEBMLVarInt(ebml.data.length);
              ebml.dataOffset = buffer.pos + bufferFileOffset;
              buffer.writeString(ebml.data);
            } else if (typeof ebml.data === "number") {
              if (!ebml.size) {
                ebml.size = buffer.measureUnsignedInt(ebml.data);
              }
              buffer.writeEBMLVarInt(ebml.size);
              ebml.dataOffset = buffer.pos + bufferFileOffset;
              buffer.writeUnsignedIntBE(ebml.data, ebml.size);
            } else if (ebml.data instanceof EBMLFloat64) {
              buffer.writeEBMLVarInt(8);
              ebml.dataOffset = buffer.pos + bufferFileOffset;
              buffer.writeDoubleBE(ebml.data.value);
            } else if (ebml.data instanceof EBMLFloat32) {
              buffer.writeEBMLVarInt(4);
              ebml.dataOffset = buffer.pos + bufferFileOffset;
              buffer.writeFloatBE(ebml.data.value);
            } else if (ebml.data instanceof Uint8Array) {
              buffer.writeEBMLVarInt(ebml.data.byteLength);
              ebml.dataOffset = buffer.pos + bufferFileOffset;
              buffer.writeBytes(ebml.data);
            } else {
              throw "Bad EBML datatype " + typeof ebml.data;
            }
          } else {
            throw "Bad EBML datatype " + typeof ebml.data;
          }
        }
        return function(options) {
          var MAX_CLUSTER_DURATION_MSEC = 5e3, DEFAULT_TRACK_NUMBER = 1, writtenHeader = false, videoWidth, videoHeight, clusterFrameBuffer = [], clusterStartTime = 0, clusterDuration = 0, optionDefaults = {
            quality: 0.95,
            // WebM image quality from 0.0 (worst) to 1.0 (best)
            fileWriter: null,
            // Chrome FileWriter in order to stream to a file instead of buffering to memory (optional)
            fd: null,
            // Node.JS file descriptor to write to instead of buffering (optional)
            // You must supply one of:
            frameDuration: null,
            // Duration of frames in milliseconds
            frameRate: null
            // Number of frames per second
          }, seekPoints = {
            Cues: { id: new Uint8Array([28, 83, 187, 107]), positionEBML: null },
            SegmentInfo: { id: new Uint8Array([21, 73, 169, 102]), positionEBML: null },
            Tracks: { id: new Uint8Array([22, 84, 174, 107]), positionEBML: null }
          }, ebmlSegment, segmentDuration = {
            "id": 17545,
            // Duration
            "data": new EBMLFloat64(0)
          }, seekHead, cues = [], blobBuffer = new BlobBuffer2(options.fileWriter || options.fd);
          function fileOffsetToSegmentRelative(fileOffset) {
            return fileOffset - ebmlSegment.dataOffset;
          }
          function createSeekHead() {
            var seekPositionEBMLTemplate = {
              "id": 21420,
              // SeekPosition
              "size": 5,
              // Allows for 32GB video files
              "data": 0
              // We'll overwrite this when the file is complete
            }, result = {
              "id": 290298740,
              // SeekHead
              "data": []
            };
            for (var name in seekPoints) {
              var seekPoint = seekPoints[name];
              seekPoint.positionEBML = Object.create(seekPositionEBMLTemplate);
              result.data.push({
                "id": 19899,
                // Seek
                "data": [
                  {
                    "id": 21419,
                    // SeekID
                    "data": seekPoint.id
                  },
                  seekPoint.positionEBML
                ]
              });
            }
            return result;
          }
          function writeHeader() {
            seekHead = createSeekHead();
            var ebmlHeader = {
              "id": 440786851,
              // EBML
              "data": [
                {
                  "id": 17030,
                  // EBMLVersion
                  "data": 1
                },
                {
                  "id": 17143,
                  // EBMLReadVersion
                  "data": 1
                },
                {
                  "id": 17138,
                  // EBMLMaxIDLength
                  "data": 4
                },
                {
                  "id": 17139,
                  // EBMLMaxSizeLength
                  "data": 8
                },
                {
                  "id": 17026,
                  // DocType
                  "data": "webm"
                },
                {
                  "id": 17031,
                  // DocTypeVersion
                  "data": 2
                },
                {
                  "id": 17029,
                  // DocTypeReadVersion
                  "data": 2
                }
              ]
            }, segmentInfo = {
              "id": 357149030,
              // Info
              "data": [
                {
                  "id": 2807729,
                  // TimecodeScale
                  "data": 1e6
                  // Times will be in miliseconds (1e6 nanoseconds per step = 1ms)
                },
                {
                  "id": 19840,
                  // MuxingApp
                  "data": "webm-writer-js"
                },
                {
                  "id": 22337,
                  // WritingApp
                  "data": "webm-writer-js"
                },
                segmentDuration
                // To be filled in later
              ]
            }, tracks = {
              "id": 374648427,
              // Tracks
              "data": [
                {
                  "id": 174,
                  // TrackEntry
                  "data": [
                    {
                      "id": 215,
                      // TrackNumber
                      "data": DEFAULT_TRACK_NUMBER
                    },
                    {
                      "id": 29637,
                      // TrackUID
                      "data": DEFAULT_TRACK_NUMBER
                    },
                    {
                      "id": 156,
                      // FlagLacing
                      "data": 0
                    },
                    {
                      "id": 2274716,
                      // Language
                      "data": "und"
                    },
                    {
                      "id": 134,
                      // CodecID
                      "data": "V_VP8"
                    },
                    {
                      "id": 2459272,
                      // CodecName
                      "data": "VP8"
                    },
                    {
                      "id": 131,
                      // TrackType
                      "data": 1
                    },
                    {
                      "id": 224,
                      // Video
                      "data": [
                        {
                          "id": 176,
                          // PixelWidth
                          "data": videoWidth
                        },
                        {
                          "id": 186,
                          // PixelHeight
                          "data": videoHeight
                        }
                      ]
                    }
                  ]
                }
              ]
            };
            ebmlSegment = {
              "id": 408125543,
              // Segment
              "size": -1,
              // Unbounded size
              "data": [
                seekHead,
                segmentInfo,
                tracks
              ]
            };
            var bufferStream = new ArrayBufferDataStream2(256);
            writeEBML(bufferStream, blobBuffer.pos, [ebmlHeader, ebmlSegment]);
            blobBuffer.write(bufferStream.getAsDataArray());
            seekPoints.SegmentInfo.positionEBML.data = fileOffsetToSegmentRelative(segmentInfo.offset);
            seekPoints.Tracks.positionEBML.data = fileOffsetToSegmentRelative(tracks.offset);
          }
          ;
          function createKeyframeBlock(keyframe) {
            var bufferStream = new ArrayBufferDataStream2(1 + 2 + 1);
            if (!(keyframe.trackNumber > 0 && keyframe.trackNumber < 127)) {
              throw "TrackNumber must be > 0 and < 127";
            }
            bufferStream.writeEBMLVarInt(keyframe.trackNumber);
            bufferStream.writeU16BE(keyframe.timecode);
            bufferStream.writeByte(
              1 << 7
              // Keyframe
            );
            return {
              "id": 163,
              // SimpleBlock
              "data": [
                bufferStream.getAsDataArray(),
                keyframe.frame
              ]
            };
          }
          function createCluster(cluster) {
            return {
              "id": 524531317,
              "data": [
                {
                  "id": 231,
                  // Timecode
                  "data": Math.round(cluster.timecode)
                }
              ]
            };
          }
          function addCuePoint(trackIndex, clusterTime, clusterFileOffset) {
            cues.push({
              "id": 187,
              // Cue
              "data": [
                {
                  "id": 179,
                  // CueTime
                  "data": clusterTime
                },
                {
                  "id": 183,
                  // CueTrackPositions
                  "data": [
                    {
                      "id": 247,
                      // CueTrack
                      "data": trackIndex
                    },
                    {
                      "id": 241,
                      // CueClusterPosition
                      "data": fileOffsetToSegmentRelative(clusterFileOffset)
                    }
                  ]
                }
              ]
            });
          }
          function writeCues() {
            var ebml = {
              "id": 475249515,
              "data": cues
            }, cuesBuffer = new ArrayBufferDataStream2(16 + cues.length * 32);
            writeEBML(cuesBuffer, blobBuffer.pos, ebml);
            blobBuffer.write(cuesBuffer.getAsDataArray());
            seekPoints.Cues.positionEBML.data = fileOffsetToSegmentRelative(ebml.offset);
          }
          function flushClusterFrameBuffer() {
            if (clusterFrameBuffer.length == 0) {
              return;
            }
            var rawImageSize = 0;
            for (var i = 0; i < clusterFrameBuffer.length; i++) {
              rawImageSize += clusterFrameBuffer[i].frame.length;
            }
            var buffer = new ArrayBufferDataStream2(rawImageSize + clusterFrameBuffer.length * 32), cluster = createCluster({
              timecode: Math.round(clusterStartTime)
            });
            for (var i = 0; i < clusterFrameBuffer.length; i++) {
              cluster.data.push(createKeyframeBlock(clusterFrameBuffer[i]));
            }
            writeEBML(buffer, blobBuffer.pos, cluster);
            blobBuffer.write(buffer.getAsDataArray());
            addCuePoint(DEFAULT_TRACK_NUMBER, Math.round(clusterStartTime), cluster.offset);
            clusterFrameBuffer = [];
            clusterStartTime += clusterDuration;
            clusterDuration = 0;
          }
          function validateOptions() {
            if (!options.frameDuration) {
              if (options.frameRate) {
                options.frameDuration = 1e3 / options.frameRate;
              } else {
                throw "Missing required frameDuration or frameRate setting";
              }
            }
          }
          function addFrameToCluster(frame) {
            frame.trackNumber = DEFAULT_TRACK_NUMBER;
            frame.timecode = Math.round(clusterDuration);
            clusterFrameBuffer.push(frame);
            clusterDuration += frame.duration;
            if (clusterDuration >= MAX_CLUSTER_DURATION_MSEC) {
              flushClusterFrameBuffer();
            }
          }
          function rewriteSeekHead() {
            var seekHeadBuffer = new ArrayBufferDataStream2(seekHead.size), oldPos = blobBuffer.pos;
            writeEBML(seekHeadBuffer, seekHead.dataOffset, seekHead.data);
            blobBuffer.seek(seekHead.dataOffset);
            blobBuffer.write(seekHeadBuffer.getAsDataArray());
            blobBuffer.seek(oldPos);
          }
          function rewriteDuration() {
            var buffer = new ArrayBufferDataStream2(8), oldPos = blobBuffer.pos;
            buffer.writeDoubleBE(clusterStartTime);
            blobBuffer.seek(segmentDuration.dataOffset);
            blobBuffer.write(buffer.getAsDataArray());
            blobBuffer.seek(oldPos);
          }
          this.addFrame = function(canvas) {
            if (writtenHeader) {
              if (canvas.width != videoWidth || canvas.height != videoHeight) {
                throw "Frame size differs from previous frames";
              }
            } else {
              videoWidth = canvas.width;
              videoHeight = canvas.height;
              writeHeader();
              writtenHeader = true;
            }
            var webP = renderAsWebP(canvas, { quality: options.quality });
            if (!webP) {
              throw "Couldn't decode WebP frame, does the browser support WebP?";
            }
            addFrameToCluster({
              frame: extractKeyframeFromWebP(webP),
              duration: options.frameDuration
            });
          };
          this.complete = function() {
            flushClusterFrameBuffer();
            writeCues();
            rewriteSeekHead();
            rewriteDuration();
            return blobBuffer.complete("video/webm");
          };
          this.getWrittenSize = function() {
            return blobBuffer.length;
          };
          options = extend(optionDefaults, options || {});
          validateOptions();
        };
      };
      if (isNodeEnviroment) {
        module.exports = WebMWriter(ArrayBufferDataStream, BlobBuffer);
      } else {
        window.WebMWriter = WebMWriter(ArrayBufferDataStream, BlobBuffer);
      }
    })();
  }
});

// node_modules/ccapture.js-npmfixed/src/CCapture.js
var require_CCapture = __commonJS({
  "node_modules/ccapture.js-npmfixed/src/CCapture.js"(exports, module) {
    (function() {
      "use strict";
      var isNodeEnviroment = typeof module !== "undefined" && typeof module.exports !== "undefined";
      var Tar = isNodeEnviroment ? require_tar() : window.Tar;
      var download = isNodeEnviroment ? require_download() : window.download;
      var GIF = isNodeEnviroment ? require_gif().GIF : window.GIF;
      var WebMWriter = isNodeEnviroment ? require_webm_writer_0_2_0() : window.WebMWriter;
      var objectTypes = {
        "function": true,
        "object": true
      };
      function checkGlobal(value) {
        return value && value.Object === Object ? value : null;
      }
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType ? exports : void 0;
      var freeModule = objectTypes[typeof module] && module && !module.nodeType ? module : void 0;
      var moduleExports = freeModule && freeModule.exports === freeExports ? freeExports : void 0;
      var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == "object" && global);
      var freeSelf = checkGlobal(objectTypes[typeof self] && self);
      var freeWindow = checkGlobal(objectTypes[typeof window] && window);
      var thisGlobal = checkGlobal(objectTypes[typeof this] && this);
      var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function("return this")();
      if (!("gc" in window)) {
        window.gc = function() {
        };
      }
      if (!HTMLCanvasElement.prototype.toBlob) {
        Object.defineProperty(HTMLCanvasElement.prototype, "toBlob", {
          value: function(callback, type, quality) {
            var binStr = atob(this.toDataURL(type, quality).split(",")[1]), len = binStr.length, arr = new Uint8Array(len);
            for (var i = 0; i < len; i++) {
              arr[i] = binStr.charCodeAt(i);
            }
            callback(new Blob([arr], { type: type || "image/png" }));
          }
        });
      }
      (function() {
        if ("performance" in window == false) {
          window.performance = {};
        }
        Date.now = Date.now || function() {
          return (/* @__PURE__ */ new Date()).getTime();
        };
        if ("now" in window.performance == false) {
          var nowOffset = Date.now();
          if (performance.timing && performance.timing.navigationStart) {
            nowOffset = performance.timing.navigationStart;
          }
          window.performance.now = function now() {
            return Date.now() - nowOffset;
          };
        }
      })();
      function pad(n) {
        return String("0000000" + n).slice(-7);
      }
      var g_startTime = window.Date.now();
      function guid() {
        function s4() {
          return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
        }
        return s4() + s4() + "-" + s4() + "-" + s4() + "-" + s4() + "-" + s4() + s4() + s4();
      }
      function CCFrameEncoder(settings) {
        var _handlers = {};
        this.settings = settings;
        this.on = function(event, handler) {
          _handlers[event] = handler;
        };
        this.emit = function(event) {
          var handler = _handlers[event];
          if (handler) {
            handler.apply(null, Array.prototype.slice.call(arguments, 1));
          }
        };
        this.filename = settings.name || guid();
        this.extension = "";
        this.mimeType = "";
      }
      CCFrameEncoder.prototype.start = function() {
      };
      CCFrameEncoder.prototype.stop = function() {
      };
      CCFrameEncoder.prototype.add = function() {
      };
      CCFrameEncoder.prototype.save = function() {
      };
      CCFrameEncoder.prototype.dispose = function() {
      };
      CCFrameEncoder.prototype.safeToProceed = function() {
        return true;
      };
      CCFrameEncoder.prototype.step = function() {
        console.log("Step not set!");
      };
      function CCTarEncoder(settings) {
        CCFrameEncoder.call(this, settings);
        this.extension = ".tar";
        this.mimeType = "application/x-tar";
        this.fileExtension = "";
        this.baseFilename = this.filename;
        this.tape = null;
        this.count = 0;
        this.part = 1;
        this.frames = 0;
      }
      CCTarEncoder.prototype = Object.create(CCFrameEncoder.prototype);
      CCTarEncoder.prototype.start = function() {
        this.dispose();
      };
      CCTarEncoder.prototype.add = function(blob) {
        var fileReader = new FileReader();
        fileReader.onload = (function() {
          this.tape.append(pad(this.count) + this.fileExtension, new Uint8Array(fileReader.result));
          if (this.settings.autoSaveTime > 0 && this.frames / this.settings.framerate >= this.settings.autoSaveTime) {
            this.save((function(blob2) {
              this.filename = this.baseFilename + "-part-" + pad(this.part);
              download(blob2, this.filename + this.extension, this.mimeType);
              var count = this.count;
              this.dispose();
              this.count = count + 1;
              this.part++;
              this.filename = this.baseFilename + "-part-" + pad(this.part);
              this.frames = 0;
              this.step();
            }).bind(this));
          } else {
            this.count++;
            this.frames++;
            this.step();
          }
        }).bind(this);
        fileReader.readAsArrayBuffer(blob);
      };
      CCTarEncoder.prototype.save = function(callback) {
        callback(this.tape.save());
      };
      CCTarEncoder.prototype.dispose = function() {
        this.tape = new Tar();
        this.count = 0;
      };
      function CCPNGEncoder(settings) {
        CCTarEncoder.call(this, settings);
        this.type = "image/png";
        this.fileExtension = ".png";
      }
      CCPNGEncoder.prototype = Object.create(CCTarEncoder.prototype);
      CCPNGEncoder.prototype.add = function(canvas) {
        canvas.toBlob((function(blob) {
          CCTarEncoder.prototype.add.call(this, blob);
        }).bind(this), this.type);
      };
      function CCJPEGEncoder(settings) {
        CCTarEncoder.call(this, settings);
        this.type = "image/jpeg";
        this.fileExtension = ".jpg";
        this.quality = settings.quality / 100 || 0.8;
      }
      CCJPEGEncoder.prototype = Object.create(CCTarEncoder.prototype);
      CCJPEGEncoder.prototype.add = function(canvas) {
        canvas.toBlob((function(blob) {
          CCTarEncoder.prototype.add.call(this, blob);
        }).bind(this), this.type, this.quality);
      };
      function CCWebMEncoder(settings) {
        var canvas = document.createElement("canvas");
        if (canvas.toDataURL("image/webp").substr(5, 10) !== "image/webp") {
          console.log("WebP not supported - try another export format");
        }
        CCFrameEncoder.call(this, settings);
        this.quality = settings.quality / 100 || 0.8;
        this.extension = ".webm";
        this.mimeType = "video/webm";
        this.baseFilename = this.filename;
        this.framerate = settings.framerate;
        this.frames = 0;
        this.part = 1;
        this.videoWriter = new WebMWriter({
          quality: this.quality,
          fileWriter: null,
          fd: null,
          frameRate: this.framerate
        });
      }
      CCWebMEncoder.prototype = Object.create(CCFrameEncoder.prototype);
      CCWebMEncoder.prototype.start = function(canvas) {
        this.dispose();
      };
      CCWebMEncoder.prototype.add = function(canvas) {
        this.videoWriter.addFrame(canvas);
        if (this.settings.autoSaveTime > 0 && this.frames / this.settings.framerate >= this.settings.autoSaveTime) {
          this.save((function(blob) {
            this.filename = this.baseFilename + "-part-" + pad(this.part);
            download(blob, this.filename + this.extension, this.mimeType);
            this.dispose();
            this.part++;
            this.filename = this.baseFilename + "-part-" + pad(this.part);
            this.step();
          }).bind(this));
        } else {
          this.frames++;
          this.step();
        }
      };
      CCWebMEncoder.prototype.save = function(callback) {
        this.videoWriter.complete().then(callback);
      };
      CCWebMEncoder.prototype.dispose = function(canvas) {
        this.frames = 0;
        this.videoWriter = new WebMWriter({
          quality: this.quality,
          fileWriter: null,
          fd: null,
          frameRate: this.framerate
        });
      };
      function CCFFMpegServerEncoder(settings) {
        CCFrameEncoder.call(this, settings);
        settings.quality = settings.quality / 100 || 0.8;
        this.encoder = new FFMpegServer.Video(settings);
        this.encoder.on("process", (function() {
          this.emit("process");
        }).bind(this));
        this.encoder.on("finished", (function(url, size) {
          var cb = this.callback;
          if (cb) {
            this.callback = void 0;
            cb(url, size);
          }
        }).bind(this));
        this.encoder.on("progress", (function(progress) {
          if (this.settings.onProgress) {
            this.settings.onProgress(progress);
          }
        }).bind(this));
        this.encoder.on("error", (function(data) {
          alert(JSON.stringify(data, null, 2));
        }).bind(this));
      }
      CCFFMpegServerEncoder.prototype = Object.create(CCFrameEncoder.prototype);
      CCFFMpegServerEncoder.prototype.start = function() {
        this.encoder.start(this.settings);
      };
      CCFFMpegServerEncoder.prototype.add = function(canvas) {
        this.encoder.add(canvas);
      };
      CCFFMpegServerEncoder.prototype.save = function(callback) {
        this.callback = callback;
        this.encoder.end();
      };
      CCFFMpegServerEncoder.prototype.safeToProceed = function() {
        return this.encoder.safeToProceed();
      };
      function CCStreamEncoder(settings) {
        CCFrameEncoder.call(this, settings);
        this.framerate = this.settings.framerate;
        this.type = "video/webm";
        this.extension = ".webm";
        this.stream = null;
        this.mediaRecorder = null;
        this.chunks = [];
      }
      CCStreamEncoder.prototype = Object.create(CCFrameEncoder.prototype);
      CCStreamEncoder.prototype.add = function(canvas) {
        if (!this.stream) {
          this.stream = canvas.captureStream(this.framerate);
          this.mediaRecorder = new MediaRecorder(this.stream);
          this.mediaRecorder.start();
          this.mediaRecorder.ondataavailable = (function(e) {
            this.chunks.push(e.data);
          }).bind(this);
        }
        this.step();
      };
      CCStreamEncoder.prototype.save = function(callback) {
        this.mediaRecorder.onstop = (function(e) {
          var blob = new Blob(this.chunks, { "type": "video/webm" });
          this.chunks = [];
          callback(blob);
        }).bind(this);
        this.mediaRecorder.stop();
      };
      function CCGIFEncoder(settings) {
        CCFrameEncoder.call(this, settings);
        settings.quality = 31 - (settings.quality * 30 / 100 || 10);
        settings.workers = settings.workers || 4;
        this.extension = ".gif";
        this.mimeType = "image/gif";
        this.canvas = document.createElement("canvas");
        this.ctx = this.canvas.getContext("2d");
        this.sizeSet = false;
        var gifWorkerText = "(function(b){function a(b,d){if({}.hasOwnProperty.call(a.cache,b))return a.cache[b];var e=a.resolve(b);if(!e)throw new Error('Failed to resolve module '+b);var c={id:b,require:a,filename:b,exports:{},loaded:!1,parent:d,children:[]};d&&d.children.push(c);var f=b.slice(0,b.lastIndexOf('/')+1);return a.cache[b]=c.exports,e.call(c.exports,c,c.exports,f,b),c.loaded=!0,a.cache[b]=c.exports}a.modules={},a.cache={},a.resolve=function(b){return{}.hasOwnProperty.call(a.modules,b)?a.modules[b]:void 0},a.define=function(b,c){a.modules[b]=c},a.define('/gif.worker.coffee',function(d,e,f,g){var b,c;b=a('/GIFEncoder.js',d),c=function(a){var c,e,d,f;return c=new b(a.width,a.height),a.index===0?c.writeHeader():c.firstFrame=!1,c.setTransparent(a.transparent),c.setRepeat(a.repeat),c.setDelay(a.delay),c.setQuality(a.quality),c.addFrame(a.data),a.last&&c.finish(),d=c.stream(),a.data=d.pages,a.cursor=d.cursor,a.pageSize=d.constructor.pageSize,a.canTransfer?(f=function(c){for(var b=0,d=a.data.length;b<d;++b)e=a.data[b],c.push(e.buffer);return c}.call(this,[]),self.postMessage(a,f)):self.postMessage(a)},self.onmessage=function(a){return c(a.data)}}),a.define('/GIFEncoder.js',function(e,h,i,j){function c(){this.page=-1,this.pages=[],this.newPage()}function b(a,b){this.width=~~a,this.height=~~b,this.transparent=null,this.transIndex=0,this.repeat=-1,this.delay=0,this.image=null,this.pixels=null,this.indexedPixels=null,this.colorDepth=null,this.colorTab=null,this.usedEntry=new Array,this.palSize=7,this.dispose=-1,this.firstFrame=!0,this.sample=10,this.out=new c}var f=a('/TypedNeuQuant.js',e),g=a('/LZWEncoder.js',e);c.pageSize=4096,c.charMap={};for(var d=0;d<256;d++)c.charMap[d]=String.fromCharCode(d);c.prototype.newPage=function(){this.pages[++this.page]=new Uint8Array(c.pageSize),this.cursor=0},c.prototype.getData=function(){var d='';for(var a=0;a<this.pages.length;a++)for(var b=0;b<c.pageSize;b++)d+=c.charMap[this.pages[a][b]];return d},c.prototype.writeByte=function(a){this.cursor>=c.pageSize&&this.newPage(),this.pages[this.page][this.cursor++]=a},c.prototype.writeUTFBytes=function(b){for(var c=b.length,a=0;a<c;a++)this.writeByte(b.charCodeAt(a))},c.prototype.writeBytes=function(b,d,e){for(var c=e||b.length,a=d||0;a<c;a++)this.writeByte(b[a])},b.prototype.setDelay=function(a){this.delay=Math.round(a/10)},b.prototype.setFrameRate=function(a){this.delay=Math.round(100/a)},b.prototype.setDispose=function(a){a>=0&&(this.dispose=a)},b.prototype.setRepeat=function(a){this.repeat=a},b.prototype.setTransparent=function(a){this.transparent=a},b.prototype.addFrame=function(a){this.image=a,this.getImagePixels(),this.analyzePixels(),this.firstFrame&&(this.writeLSD(),this.writePalette(),this.repeat>=0&&this.writeNetscapeExt()),this.writeGraphicCtrlExt(),this.writeImageDesc(),this.firstFrame||this.writePalette(),this.writePixels(),this.firstFrame=!1},b.prototype.finish=function(){this.out.writeByte(59)},b.prototype.setQuality=function(a){a<1&&(a=1),this.sample=a},b.prototype.writeHeader=function(){this.out.writeUTFBytes('GIF89a')},b.prototype.analyzePixels=function(){var g=this.pixels.length,d=g/3;this.indexedPixels=new Uint8Array(d);var a=new f(this.pixels,this.sample);a.buildColormap(),this.colorTab=a.getColormap();var b=0;for(var c=0;c<d;c++){var e=a.lookupRGB(this.pixels[b++]&255,this.pixels[b++]&255,this.pixels[b++]&255);this.usedEntry[e]=!0,this.indexedPixels[c]=e}this.pixels=null,this.colorDepth=8,this.palSize=7,this.transparent!==null&&(this.transIndex=this.findClosest(this.transparent))},b.prototype.findClosest=function(e){if(this.colorTab===null)return-1;var k=(e&16711680)>>16,l=(e&65280)>>8,m=e&255,c=0,d=16777216,j=this.colorTab.length;for(var a=0;a<j;){var f=k-(this.colorTab[a++]&255),g=l-(this.colorTab[a++]&255),h=m-(this.colorTab[a]&255),i=f*f+g*g+h*h,b=parseInt(a/3);this.usedEntry[b]&&i<d&&(d=i,c=b),a++}return c},b.prototype.getImagePixels=function(){var a=this.width,g=this.height;this.pixels=new Uint8Array(a*g*3);var b=this.image,c=0;for(var d=0;d<g;d++)for(var e=0;e<a;e++){var f=d*a*4+e*4;this.pixels[c++]=b[f],this.pixels[c++]=b[f+1],this.pixels[c++]=b[f+2]}},b.prototype.writeGraphicCtrlExt=function(){this.out.writeByte(33),this.out.writeByte(249),this.out.writeByte(4);var b,a;this.transparent===null?(b=0,a=0):(b=1,a=2),this.dispose>=0&&(a=dispose&7),a<<=2,this.out.writeByte(0|a|0|b),this.writeShort(this.delay),this.out.writeByte(this.transIndex),this.out.writeByte(0)},b.prototype.writeImageDesc=function(){this.out.writeByte(44),this.writeShort(0),this.writeShort(0),this.writeShort(this.width),this.writeShort(this.height),this.firstFrame?this.out.writeByte(0):this.out.writeByte(128|this.palSize)},b.prototype.writeLSD=function(){this.writeShort(this.width),this.writeShort(this.height),this.out.writeByte(240|this.palSize),this.out.writeByte(0),this.out.writeByte(0)},b.prototype.writeNetscapeExt=function(){this.out.writeByte(33),this.out.writeByte(255),this.out.writeByte(11),this.out.writeUTFBytes('NETSCAPE2.0'),this.out.writeByte(3),this.out.writeByte(1),this.writeShort(this.repeat),this.out.writeByte(0)},b.prototype.writePalette=function(){this.out.writeBytes(this.colorTab);var b=768-this.colorTab.length;for(var a=0;a<b;a++)this.out.writeByte(0)},b.prototype.writeShort=function(a){this.out.writeByte(a&255),this.out.writeByte(a>>8&255)},b.prototype.writePixels=function(){var a=new g(this.width,this.height,this.indexedPixels,this.colorDepth);a.encode(this.out)},b.prototype.stream=function(){return this.out},e.exports=b}),a.define('/LZWEncoder.js',function(e,g,h,i){function f(y,D,C,B){function w(a,b){r[f++]=a,f>=254&&t(b)}function x(b){u(a),k=i+2,j=!0,l(i,b)}function u(b){for(var a=0;a<b;++a)h[a]=-1}function A(z,r){var g,t,d,e,y,w,s;for(q=z,j=!1,n_bits=q,m=p(n_bits),i=1<<z-1,o=i+1,k=i+2,f=0,e=v(),s=0,g=a;g<65536;g*=2)++s;s=8-s,w=a,u(w),l(i,r);a:while((t=v())!=c){if(g=(t<<b)+e,d=t<<s^e,h[d]===g){e=n[d];continue}if(h[d]>=0){y=w-d,d===0&&(y=1);do if((d-=y)<0&&(d+=w),h[d]===g){e=n[d];continue a}while(h[d]>=0)}l(e,r),e=t,k<1<<b?(n[d]=k++,h[d]=g):x(r)}l(e,r),l(o,r)}function z(a){a.writeByte(s),remaining=y*D,curPixel=0,A(s+1,a),a.writeByte(0)}function t(a){f>0&&(a.writeByte(f),a.writeBytes(r,0,f),f=0)}function p(a){return(1<<a)-1}function v(){if(remaining===0)return c;--remaining;var a=C[curPixel++];return a&255}function l(a,c){g&=d[e],e>0?g|=a<<e:g=a,e+=n_bits;while(e>=8)w(g&255,c),g>>=8,e-=8;if((k>m||j)&&(j?(m=p(n_bits=q),j=!1):(++n_bits,n_bits==b?m=1<<b:m=p(n_bits))),a==o){while(e>0)w(g&255,c),g>>=8,e-=8;t(c)}}var s=Math.max(2,B),r=new Uint8Array(256),h=new Int32Array(a),n=new Int32Array(a),g,e=0,f,k=0,m,j=!1,q,i,o;this.encode=z}var c=-1,b=12,a=5003,d=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535];e.exports=f}),a.define('/TypedNeuQuant.js',function(A,F,E,D){function C(A,B){function I(){o=[],q=new Int32Array(256),t=new Int32Array(a),y=new Int32Array(a),z=new Int32Array(a>>3);var c,d;for(c=0;c<a;c++)d=(c<<b+8)/a,o[c]=new Float64Array([d,d,d,0]),y[c]=e/a,t[c]=0}function J(){for(var c=0;c<a;c++)o[c][0]>>=b,o[c][1]>>=b,o[c][2]>>=b,o[c][3]=c}function K(b,a,c,e,f){o[a][0]-=b*(o[a][0]-c)/d,o[a][1]-=b*(o[a][1]-e)/d,o[a][2]-=b*(o[a][2]-f)/d}function L(j,e,n,l,k){var h=Math.abs(e-j),i=Math.min(e+j,a),g=e+1,f=e-1,m=1,b,d;while(g<i||f>h)d=z[m++],g<i&&(b=o[g++],b[0]-=d*(b[0]-n)/c,b[1]-=d*(b[1]-l)/c,b[2]-=d*(b[2]-k)/c),f>h&&(b=o[f--],b[0]-=d*(b[0]-n)/c,b[1]-=d*(b[1]-l)/c,b[2]-=d*(b[2]-k)/c)}function C(p,s,q){var h=2147483647,k=h,d=-1,m=d,c,j,e,n,l;for(c=0;c<a;c++)j=o[c],e=Math.abs(j[0]-p)+Math.abs(j[1]-s)+Math.abs(j[2]-q),e<h&&(h=e,d=c),n=e-(t[c]>>i-b),n<k&&(k=n,m=c),l=y[c]>>g,y[c]-=l,t[c]+=l<<f;return y[d]+=x,t[d]-=r,m}function D(){var d,b,e,c,h,g,f=0,i=0;for(d=0;d<a;d++){for(e=o[d],h=d,g=e[1],b=d+1;b<a;b++)c=o[b],c[1]<g&&(h=b,g=c[1]);if(c=o[h],d!=h&&(b=c[0],c[0]=e[0],e[0]=b,b=c[1],c[1]=e[1],e[1]=b,b=c[2],c[2]=e[2],e[2]=b,b=c[3],c[3]=e[3],e[3]=b),g!=f){for(q[f]=i+d>>1,b=f+1;b<g;b++)q[b]=d;f=g,i=d}}for(q[f]=i+n>>1,b=f+1;b<256;b++)q[b]=n}function E(j,i,k){var b,d,c,e=1e3,h=-1,f=q[i],g=f-1;while(f<a||g>=0)f<a&&(d=o[f],c=d[1]-i,c>=e?f=a:(f++,c<0&&(c=-c),b=d[0]-j,b<0&&(b=-b),c+=b,c<e&&(b=d[2]-k,b<0&&(b=-b),c+=b,c<e&&(e=c,h=d[3])))),g>=0&&(d=o[g],c=i-d[1],c>=e?g=-1:(g--,c<0&&(c=-c),b=d[0]-j,b<0&&(b=-b),c+=b,c<e&&(b=d[2]-k,b<0&&(b=-b),c+=b,c<e&&(e=c,h=d[3]))));return h}function F(){var c,f=A.length,D=30+(B-1)/3,y=f/(3*B),q=~~(y/w),n=d,o=u,a=o>>h;for(a<=1&&(a=0),c=0;c<a;c++)z[c]=n*((a*a-c*c)*m/(a*a));var i;f<s?(B=1,i=3):f%l!==0?i=3*l:f%k!==0?i=3*k:f%p!==0?i=3*p:i=3*j;var r,t,x,e,g=0;c=0;while(c<y)if(r=(A[g]&255)<<b,t=(A[g+1]&255)<<b,x=(A[g+2]&255)<<b,e=C(r,t,x),K(n,e,r,t,x),a!==0&&L(a,e,r,t,x),g+=i,g>=f&&(g-=f),c++,q===0&&(q=1),c%q===0)for(n-=n/D,o-=o/v,a=o>>h,a<=1&&(a=0),e=0;e<a;e++)z[e]=n*((a*a-e*e)*m/(a*a))}function G(){I(),F(),J(),D()}function H(){var b=[],g=[];for(var c=0;c<a;c++)g[o[c][3]]=c;var d=0;for(var e=0;e<a;e++){var f=g[e];b[d++]=o[f][0],b[d++]=o[f][1],b[d++]=o[f][2]}return b}var o,q,t,y,z;this.buildColormap=G,this.getColormap=H,this.lookupRGB=E}var w=100,a=256,n=a-1,b=4,i=16,e=1<<i,f=10,B=1<<f,g=10,x=e>>g,r=e<<f-g,z=a>>3,h=6,t=1<<h,u=z*t,v=30,o=10,d=1<<o,q=8,m=1<<q,y=o+q,c=1<<y,l=499,k=491,p=487,j=503,s=3*j;A.exports=C}),a('/gif.worker.coffee')}.call(this,this))";
        var workerBlob = new Blob([gifWorkerText], {
          type: "application/javascript"
        });
        var workerScript = URL.createObjectURL(workerBlob);
        this.encoder = new GIF({
          workers: settings.workers,
          quality: settings.quality,
          workerScript
        });
        this.encoder.on("progress", (function(progress) {
          if (this.settings.onProgress) {
            this.settings.onProgress(progress);
          }
        }).bind(this));
        this.encoder.on("finished", (function(blob) {
          var cb = this.callback;
          if (cb) {
            this.callback = void 0;
            cb(blob);
          }
        }).bind(this));
      }
      CCGIFEncoder.prototype = Object.create(CCFrameEncoder.prototype);
      CCGIFEncoder.prototype.add = function(canvas) {
        if (!this.sizeSet) {
          this.encoder.setOption("width", canvas.width);
          this.encoder.setOption("height", canvas.height);
          this.sizeSet = true;
        }
        this.canvas.width = canvas.width;
        this.canvas.height = canvas.height;
        this.ctx.drawImage(canvas, 0, 0);
        this.encoder.addFrame(this.ctx, { copy: true, delay: this.settings.step });
        this.step();
      };
      CCGIFEncoder.prototype.save = function(callback) {
        this.callback = callback;
        this.encoder.render();
      };
      function CCapture(settings) {
        var _settings = settings || {}, _date = /* @__PURE__ */ new Date(), _verbose, _display, _time, _startTime, _performanceTime, _performanceStartTime, _step, _encoder, _timeouts = [], _intervals = [], _frameCount = 0, _intermediateFrameCount = 0, _lastFrame = null, _requestAnimationFrameCallbacks = [], _capturing = false, _handlers = {};
        _settings.framerate = _settings.framerate || 60;
        _settings.motionBlurFrames = 2 * (_settings.motionBlurFrames || 1);
        _verbose = _settings.verbose || false;
        _display = _settings.display || false;
        _settings.step = 1e3 / _settings.framerate;
        _settings.timeLimit = _settings.timeLimit || 0;
        _settings.frameLimit = _settings.frameLimit || 0;
        _settings.startTime = _settings.startTime || 0;
        var _timeDisplay = document.createElement("div");
        _timeDisplay.style.position = "absolute";
        _timeDisplay.style.left = _timeDisplay.style.top = 0;
        _timeDisplay.style.backgroundColor = "black";
        _timeDisplay.style.fontFamily = "monospace";
        _timeDisplay.style.fontSize = "11px";
        _timeDisplay.style.padding = "5px";
        _timeDisplay.style.color = "red";
        _timeDisplay.style.zIndex = 1e5;
        if (_settings.display) document.body.appendChild(_timeDisplay);
        var canvasMotionBlur = document.createElement("canvas");
        var ctxMotionBlur = canvasMotionBlur.getContext("2d");
        var bufferMotionBlur;
        var imageData;
        _log("Step is set to " + _settings.step + "ms");
        var _encoders = {
          gif: CCGIFEncoder,
          webm: CCWebMEncoder,
          ffmpegserver: CCFFMpegServerEncoder,
          png: CCPNGEncoder,
          jpg: CCJPEGEncoder,
          "webm-mediarecorder": CCStreamEncoder
        };
        var ctor = _encoders[_settings.format];
        if (!ctor) {
          throw "Error: Incorrect or missing format: Valid formats are " + Object.keys(_encoders).join(", ");
        }
        _encoder = new ctor(_settings);
        _encoder.step = _step;
        _encoder.on("process", _process);
        _encoder.on("progress", _progress);
        if ("performance" in window == false) {
          window.performance = {};
        }
        Date.now = Date.now || function() {
          return (/* @__PURE__ */ new Date()).getTime();
        };
        if ("now" in window.performance == false) {
          var nowOffset = Date.now();
          if (performance.timing && performance.timing.navigationStart) {
            nowOffset = performance.timing.navigationStart;
          }
          window.performance.now = function now() {
            return Date.now() - nowOffset;
          };
        }
        var _oldSetTimeout = window.setTimeout, _oldSetInterval = window.setInterval, _oldClearInterval = window.clearInterval, _oldClearTimeout = window.clearTimeout, _oldRequestAnimationFrame = window.requestAnimationFrame, _oldNow = window.Date.now, _oldPerformanceNow = window.performance.now, _oldGetTime = window.Date.prototype.getTime;
        var media = [];
        function _init() {
          _log("Capturer start");
          _startTime = window.Date.now();
          _time = _startTime + _settings.startTime;
          _performanceStartTime = window.performance.now();
          _performanceTime = _performanceStartTime + _settings.startTime;
          window.Date.prototype.getTime = function() {
            return _time;
          };
          window.Date.now = function() {
            return _time;
          };
          window.setTimeout = function(callback, time) {
            var t = {
              callback,
              time,
              triggerTime: _time + time
            };
            _timeouts.push(t);
            _log("Timeout set to " + t.time);
            return t;
          };
          window.clearTimeout = function(id) {
            for (var j = 0; j < _timeouts.length; j++) {
              if (_timeouts[j] == id) {
                _timeouts.splice(j, 1);
                _log("Timeout cleared");
                continue;
              }
            }
          };
          window.setInterval = function(callback, time) {
            var t = {
              callback,
              time,
              triggerTime: _time + time
            };
            _intervals.push(t);
            _log("Interval set to " + t.time);
            return t;
          };
          window.clearInterval = function(id) {
            _log("clear Interval");
            return null;
          };
          window.requestAnimationFrame = function(callback) {
            _requestAnimationFrameCallbacks.push(callback);
          };
          window.performance.now = function() {
            return _performanceTime;
          };
          function hookCurrentTime() {
            if (!this._hooked) {
              this._hooked = true;
              this._hookedTime = this.currentTime || 0;
              this.pause();
              media.push(this);
            }
            return this._hookedTime + _settings.startTime;
          }
          ;
          try {
            Object.defineProperty(HTMLVideoElement.prototype, "currentTime", { get: hookCurrentTime });
            Object.defineProperty(HTMLAudioElement.prototype, "currentTime", { get: hookCurrentTime });
          } catch (err) {
            _log(err);
          }
        }
        function _start() {
          _init();
          _encoder.start();
          _capturing = true;
        }
        function _stop() {
          _capturing = false;
          _encoder.stop();
          _destroy();
        }
        function _call(fn, p) {
          _oldSetTimeout(fn, 0, p);
        }
        function _step() {
          _call(_process);
        }
        function _destroy() {
          _log("Capturer stop");
          window.setTimeout = _oldSetTimeout;
          window.setInterval = _oldSetInterval;
          window.clearInterval = _oldClearInterval;
          window.clearTimeout = _oldClearTimeout;
          window.requestAnimationFrame = _oldRequestAnimationFrame;
          window.Date.prototype.getTime = _oldGetTime;
          window.Date.now = _oldNow;
          window.performance.now = _oldPerformanceNow;
        }
        function _updateTime() {
          var seconds = _frameCount / _settings.framerate;
          if (_settings.frameLimit && _frameCount >= _settings.frameLimit || _settings.timeLimit && seconds >= _settings.timeLimit) {
            _stop();
            _save();
          }
          var d = /* @__PURE__ */ new Date(null);
          d.setSeconds(seconds);
          if (_settings.motionBlurFrames > 2) {
            _timeDisplay.textContent = "CCapture " + _settings.format + " | " + _frameCount + " frames (" + _intermediateFrameCount + " inter) | " + d.toISOString().substr(11, 8);
          } else {
            _timeDisplay.textContent = "CCapture " + _settings.format + " | " + _frameCount + " frames | " + d.toISOString().substr(11, 8);
          }
        }
        function _checkFrame(canvas) {
          if (canvasMotionBlur.width !== canvas.width || canvasMotionBlur.height !== canvas.height) {
            canvasMotionBlur.width = canvas.width;
            canvasMotionBlur.height = canvas.height;
            bufferMotionBlur = new Uint16Array(canvasMotionBlur.height * canvasMotionBlur.width * 4);
            ctxMotionBlur.fillStyle = "#0";
            ctxMotionBlur.fillRect(0, 0, canvasMotionBlur.width, canvasMotionBlur.height);
          }
        }
        function _blendFrame(canvas) {
          ctxMotionBlur.drawImage(canvas, 0, 0);
          imageData = ctxMotionBlur.getImageData(0, 0, canvasMotionBlur.width, canvasMotionBlur.height);
          for (var j = 0; j < bufferMotionBlur.length; j += 4) {
            bufferMotionBlur[j] += imageData.data[j];
            bufferMotionBlur[j + 1] += imageData.data[j + 1];
            bufferMotionBlur[j + 2] += imageData.data[j + 2];
          }
          _intermediateFrameCount++;
        }
        function _saveFrame() {
          var data = imageData.data;
          for (var j = 0; j < bufferMotionBlur.length; j += 4) {
            data[j] = bufferMotionBlur[j] * 2 / _settings.motionBlurFrames;
            data[j + 1] = bufferMotionBlur[j + 1] * 2 / _settings.motionBlurFrames;
            data[j + 2] = bufferMotionBlur[j + 2] * 2 / _settings.motionBlurFrames;
          }
          ctxMotionBlur.putImageData(imageData, 0, 0);
          _encoder.add(canvasMotionBlur);
          _frameCount++;
          _intermediateFrameCount = 0;
          _log("Full MB Frame! " + _frameCount + " " + _time);
          for (var j = 0; j < bufferMotionBlur.length; j += 4) {
            bufferMotionBlur[j] = 0;
            bufferMotionBlur[j + 1] = 0;
            bufferMotionBlur[j + 2] = 0;
          }
          gc();
        }
        function _capture(canvas) {
          if (_capturing) {
            if (_settings.motionBlurFrames > 2) {
              _checkFrame(canvas);
              _blendFrame(canvas);
              if (_intermediateFrameCount >= 0.5 * _settings.motionBlurFrames) {
                _saveFrame();
              } else {
                _step();
              }
            } else {
              _encoder.add(canvas);
              _frameCount++;
              _log("Full Frame! " + _frameCount);
            }
          }
        }
        function _process() {
          var step = 1e3 / _settings.framerate;
          var dt = (_frameCount + _intermediateFrameCount / _settings.motionBlurFrames) * step;
          _time = _startTime + dt;
          _performanceTime = _performanceStartTime + dt;
          media.forEach(function(v) {
            v._hookedTime = dt / 1e3;
          });
          _updateTime();
          _log("Frame: " + _frameCount + " " + _intermediateFrameCount);
          for (var j = 0; j < _timeouts.length; j++) {
            if (_time >= _timeouts[j].triggerTime) {
              _call(_timeouts[j].callback);
              _timeouts.splice(j, 1);
              continue;
            }
          }
          for (var j = 0; j < _intervals.length; j++) {
            if (_time >= _intervals[j].triggerTime) {
              _call(_intervals[j].callback);
              _intervals[j].triggerTime += _intervals[j].time;
              continue;
            }
          }
          _requestAnimationFrameCallbacks.forEach(function(cb) {
            _call(cb, _time - g_startTime);
          });
          _requestAnimationFrameCallbacks = [];
        }
        function _save(callback) {
          if (!callback) {
            callback = function(blob) {
              download(blob, _encoder.filename + _encoder.extension, _encoder.mimeType);
              return false;
            };
          }
          _encoder.save(callback);
        }
        function _log(message) {
          if (_verbose) console.log(message);
        }
        function _on(event, handler) {
          _handlers[event] = handler;
        }
        function _emit(event) {
          var handler = _handlers[event];
          if (handler) {
            handler.apply(null, Array.prototype.slice.call(arguments, 1));
          }
        }
        function _progress(progress) {
          _emit("progress", progress);
        }
        return {
          start: _start,
          capture: _capture,
          stop: _stop,
          save: _save,
          on: _on
        };
      }
      (freeWindow || freeSelf || {}).CCapture = CCapture;
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define(function() {
          return CCapture;
        });
      } else if (freeExports && freeModule) {
        if (moduleExports) {
          (freeModule.exports = CCapture).CCapture = CCapture;
        }
        freeExports.CCapture = CCapture;
      } else {
        root.CCapture = CCapture;
      }
    })();
  }
});
export default require_CCapture();
/*! Bundled license information:

ccapture.js-npmfixed/src/CCapture.js:
  (* @license http://opensource.org/licenses/MIT *)
*/
//# sourceMappingURL=ccapture__js-npmfixed.js.map
